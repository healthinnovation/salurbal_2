---
title: "Trajectory Analysis - II"
author:
  - name: Brian Peña-Calero
    email: brian.pena@upch.pe
    affiliation: Innovar, UPCH
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: yes
    code_folding: show
    code_download: yes
    theme: 
      bootswatch: flatly
    highlight: kate
    highlight_downlit: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  dpi = 300,
  fig.align = 'center'
  # message = FALSE,
  # warning = FALSE,
  # error = TRUE
)
```

# Load packages

```{r}
library(tidyverse)
library(gbmt)
#library(multidplyr)
```

# Import data

```{r}
gbmt_collect <- readRDS("01_data/processed/gbmt_collect.rds")
```

```{r}
gbmt_collect_errors <- gbmt_collect %>% 
  filter(map_lgl(.$gbmt_out, ~ !is.null(.x$error)))

gbmt_collect_clean <- gbmt_collect %>% 
  filter(map_lgl(.$gbmt_out, ~ is.null(.x$error))) %>% 
  mutate(gbmt_out = map(gbmt_out, 'result'))
```


# Fit measures

```{r}
calculate_OCC <- function(model) {
  # Encontrar el grupo asignado para cada observación según la máxima probabilidad posterior
  assigned_groups <- apply(model$posterior, 1, which.max)
  
  # Calcular la suma de las probabilidades posteriores de las asignaciones de grupo correctas
  sum_correct_probs <- sum(model$posterior[cbind(1:length(assigned_groups), assigned_groups)])
  
  # Calcular el OCC
  OCC <- sum_correct_probs / length(assigned_groups)
  
  return(OCC)
}
```


```{r}
gbmt_fit_total <- gbmt_collect_clean %>% 
  mutate(
    AIC = map_dbl(gbmt_out, AIC),
    BIC = map_dbl(gbmt_out, BIC),
    L = map_dbl(gbmt_out, logLik),
    APPA = map_dbl(gbmt_out, ~mean(.$appa)),
    Mismatch = map_dbl(gbmt_out, ~mean(1 - .$appa)),
    SD = map_dbl(gbmt_out, ~ mean(sqrt(diag(.$Sigma[[1]])))),
    OCC = map_dbl(gbmt_out, calculate_OCC),
    smallest_group = map2_dbl(gbmt_out, ng,
                             ~min(table(factor(.x$assign, levels = 1:.y))) /
                               sum(table(factor(.x$assign, levels = 1:.y))))
  ) %>% 
  select(-data) %>% 
  arrange(d, ng, scale)
```


```{r}

# Seleccionar el número óptimo de grupos según el criterio deseado (por ejemplo, el menor BIC)
selected_k <- which.min(gbmt_fit_d3_scale2$BIC)

# Crear el F-CAP con ggplot2
p1 <- ggplot(gbmt_fit_d3_scale2, aes(x = ng)) +
  geom_line(aes(y = AIC, color = "AIC")) +
  geom_line(aes(y = BIC, color = "BIC")) +
  geom_line(aes(y = L, color = "L")) +
  scale_color_manual(values = c("AIC" = "blue", "BIC" = "red", "L" = "green")) +
  labs(title = "F-CAP", x = "Number of Groups", y = "Fit Criteria") +
  scale_x_continuous(breaks = seq(1, 10, 1)) +
  theme_minimal()

p1

p2 <- p1 +
  geom_line(aes(y = APPA, color = "APPA")) +
  geom_line(aes(y = Mismatch, color = "Mismatch")) +
  geom_line(aes(y = SD, color = "SD")) +
  scale_color_manual(values = c("AIC" = "blue", "BIC" = "red", "L" = "green", "APPA" = "black", "Mismatch" = "orange", "SD" = "purple")) +
  labs(title = "F-CAP", x = "Number of Groups", y = "Fit Criteria & Model") +
  theme_minimal()

p2
```


```{r}
ggsave("02_output/plots/F-CAP-Fit-Criteria.png",
       p1, dpi = 400, bg = "white")
ggsave("02_output/plots/F-CAP-Fit-Criteria-Model.png",
       p2, dpi = 400, bg = "white")
```

# Predicted Plot

```{r}
gbmt_fit_total_predict <- gbmt_fit_total %>% 
  mutate(
    predict_values = map(gbmt_out,
                         predict),
    predict_values = map(predict_values,
                         ~ map(., ~map(., ~ as_tibble(., rownames = "Year"))) %>% 
                           bind_rows(.id = "Cluster") %>% 
                           tidyr::unpack(c(Population, BECTUAREAL1AD),
                                         names_sep = "_") %>% 
                           mutate(
                             across(c(Population_Year, BECTUAREAL1AD_Year),
                                    as.numeric)
                           ) %>% 
                           pivot_longer(
                             cols = -Cluster,
                             names_to = c("Variable", "Statistic"),
                             names_sep = "_"
                           ) %>% 
                           pivot_wider(
                             names_from = Statistic,
                             values_from = value,
                             values_fn = list
                           ) %>% 
                           unnest(
                             cols = c(Year, mean, `2.5%`, `97.5%`)
                           )),
    type_scaling = case_match(scale,
                              0 ~ "no normalisation",
                              1 ~ "centering",
                              2 ~ "standardization",
                              3 ~ "ratio to the mean",
                              4 ~ "logarithmic ratio to the mean"),
    type_polynomial = case_match(d,
                                 1 ~ "lineal (d = 1)",
                                 2 ~ "quadratic (d = 2)",
                                 3 ~ "cubic (d = 3)",
                                 4 ~ "quartic (d = 4)")
  )
```

```{r}
gbmt_fit_total_plot <- gbmt_fit_total_predict %>% 
  mutate(
    plot = pmap(list(predict_values, type_polynomial, 
                     ng, type_scaling),
                  ~ ggplot(..1,
                           aes(
                             x = Year,
                             y = mean,
                             group = Cluster,
                             color = Cluster
                           )) +
                    geom_line(linewidth = 2) +
                    scale_x_continuous(
                      breaks = seq(1985, 2015, 5)
                    ) +
                    facet_wrap(vars(Variable)) +
                    labs(
                      title = paste0("GBMT ",
                                    ..2, ", cluster number = ", ..3,
                                    ", normalisation method: ", ..4)
                    ) +
                    theme_minimal()),
    plot_ic = map(plot,
                  ~ . +
                    geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), 
                                alpha = 0.05))
  )
```


```{r}
gbmt_fit_total_plot2 <- gbmt_fit_total_plot %>% 
  filter(scale != 0) %>% 
  mutate(
    type = paste0(type_polynomial, " - cluster = ", ng,
                  ", ", type_scaling)
  ) 
  
for (i in seq_len(nrow(gbmt_fit_total_plot2))) {
    ggsave(
      filename = paste0("02_output/plots/Multiple plots/Sin IC/", gbmt_fit_total_plot2$type[i], ".png"),
      plot = gbmt_fit_total_plot2$plot[[i]],
      bg = "white",
      dpi = 300,
      width = 8,
      height = 5
    )
}
```


```{r}
library(gganimate)
```


```{r}
anim_total <- gbmt_fit_total_predict %>%
  filter(scale != 0) %>% 
  mutate(
    type = paste0(type_polynomial, " - cluster = ", ng,
                  ", ", type_scaling)
  ) %>% 
  select(type, predict_values) %>% 
  unnest(cols = c(predict_values)) %>% 
  ggplot(aes(
           x = Year,
           y = mean,
           group = Cluster,
           color = Cluster
         )) +
  geom_line(linewidth = 2) +
  scale_x_continuous(
    breaks = seq(1985, 2015, 5)
  ) +
  facet_wrap(vars(Variable)) +
  labs(
    title = paste0('Tipo de modelo: {closest_state}')
  ) +
  theme_minimal() +
  transition_states(type,
                    transition_length = 4,
                    state_length = 12) +
  enter_fade() + 
  exit_recolour() +
  ease_aes('sine-in-out')

animation <- animate(anim_total, nframes = 1600, fps = 30, width = 1280, 
                     height = 720, res = 144,
                     renderer = ffmpeg_renderer(format = "mp4"))  # crea la animación con alta calidad

anim_save("animation.mp4", animation)  # guarda la animación como un archivo MP4


```

```{r}
ggplot(mtcars, aes(factor(cyl), mpg)) + 
  geom_boxplot() + 
  # Here comes the gganimate code
  transition_states(
    gear,
    transition_length = 2,
    state_length = 1
  ) +
  enter_fade() + 
  exit_shrink() +
  ease_aes('sine-in-out')
```









```{r}


ggsave("02_output/plots/predicted_means_f.png",
       plot_predicted_means_f,
       dpi = 400,
       bg = "white")

plot(pop_bectuareal_gbmt)
coef(pop_bectuareal_gbmt)
```


```{r}
plot_predicted_means_f2 <- predicted_means_f %>% 
  ggplot(
    aes(
      x = Year,
      y = mean,
      group = Cluster,
      color = Cluster
    )
  ) +
  geom_line(size = 1) +
  #geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.05) +
  scale_x_continuous(
    breaks = seq(1985, 2015, 5)
  ) +
  facet_wrap(vars(Variable)) +
  theme_minimal()


ggsave("02_output/plots/predicted_means_f2.png",
       plot_predicted_means_f2,
       dpi = 400,
       bg = "white")
```



