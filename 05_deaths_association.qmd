---
title: "Relación con muertes"
author: "Brian Norman Peña-Calero"
date: "`r Sys.Date()`"
format: 
  html:
    toc: true
    number-sections: true
    anchor-sections: true
    code-line-numbers: true
    code-overflow: scroll
    code-copy: hover
    code-link: true
    code-fold: show
    lang: es
    embed-resources: true
lightbox: true
editor_options: 
  chunk_output_type: console
---

# Cargar paquetes

```{r}
library(tidyverse)
library(lme4)
library(lmerTest)
library(merDeriv)
library(performance)
library(parameters)
library(glmmTMB)
library(MASS)
# options(scipen = 9)

conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::select)
conflicted::conflicts_prefer(lmerTest::lmer)

options(parameters_labels = TRUE) 
```

# Importar datos

```{r}
gbmt_fit_final <- readRDS("01_data/processed/gbmt_fit_final.rds")
deaths_by_year <- read_csv(file = "01_data/processed/deaths_by_year.csv")
```

# Formato de datos

```{r}
gbmt_log_3 <- gbmt_fit_final %>% 
  filter(scale_name == "logarithmic", ng == 3) %>% 
  slice(1)

gbmt_log_3 <- gbmt_log_3$gbmt_fit_total[[1]]


gbmt_log_4 <- gbmt_fit_final %>% 
  filter(scale_name == "logarithmic", ng == 4) %>% 
  slice(1)

gbmt_log_4 <- gbmt_log_4$gbmt_fit_total[[1]]


gbmt_log <- gbmt_log_3 %>% 
  bind_rows(gbmt_log_4,
            .id = "Clusters") %>% 
  mutate(Clusters = case_match(Clusters,
                               "1" ~ 3,
                               "2" ~ 4))
```

Unificar datos:

```{r}
gbmt_log_merged <- gbmt_log %>%
  select(Clusters, ISO2, pubsalid1, SALID1, YEAR = year, population_imp_norm:group) %>% 
  inner_join(
    deaths_by_year
  ) %>% 
  mutate(deaths_per_100k = (deaths / population_imp) * 100000)
```

# Tabla descriptiva

```{r}
gbmt_log_descriptive <- gbmt_log %>%
  filter(Clusters == 4) %>% 
  select(country, ISO2, SALID1, YEAR = year, population_imp:group) %>% 
  inner_join(
    deaths_by_year
  ) %>% 
  mutate(
    country = str_to_title(country),
    deaths_per_100k = (deaths / population_imp) * 100000
  ) %>% 
  select(-c(ISO2, SALID1, YEAR, deaths)) %>% 
  relocate(group, .after = deaths_per_100k)
```

```{r}
labelled::var_label(gbmt_log_descriptive) <- list(
  country = "Country",
  population_imp = "Population",
  bectuareal1ux_imp = "Urban Area",
  deaths_per_100k	 = "Deaths per 100K",
  group = "Clusters"
)
```


```{r}
library(gtsummary)
tab1 <- gbmt_log_descriptive %>% 
  tbl_summary(
    by = group,
    percent = "row"
  ) %>% 
  modify_header(label = "") %>%
  bold_labels() %>% 
  add_overall(last = TRUE)

tab1

tab2 <- gbmt_log_descriptive %>% 
  tbl_summary(
    by = country,
    percent = "row"
  ) %>% 
  modify_header(label = "") %>%
  bold_labels() %>% 
  add_overall(last = TRUE)

tab2
```

```{r}
#| eval: false

tab1 %>%
  as_flex_table() %>%
  flextable::save_as_docx(path = "./02_output/tables/descriptive1.docx")

tab2 %>%
  as_flex_table() %>%
  flextable::save_as_docx(path = "./02_output/tables/descriptive2.docx")
```


# Gráfico inicial de promedio de muertes

```{r}
gbmt_log_merged %>% 
  group_by(Clusters, group, YEAR) %>% 
  summarise(
    deaths_per_100k = mean(deaths_per_100k)
  ) %>% 
  ungroup() %>% 
  ggplot(aes(x = YEAR, y = deaths_per_100k, color = as.factor(group))) +
  geom_line(aes(group = group)) +
  geom_point() +
  
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo a lo largo del Tiempo",
       x = "Año", y = "Muertes por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()
```


```{r} 
#| eval: false
ggsave(
  filename = "02_output/plots/promedio_muertes_group_log.png",
  dpi = 300,
  bg = "white"
)
```


# Modelo lineal mixto

## Modelo 1 (sin offset)

### Lineal

```{r}
model_3 <- lmer(
  deaths_per_100k ~ YEAR * group + (1|SALID1), 
  data = gbmt_log_merged %>% filter(Clusters == 3)
)

performance(model_3) %>% print_html()
parameters(model_3) %>% print_html()
parameters(model_3, standardize = "basic") %>% print_html()

model_4 <- lmer(
  deaths_per_100k ~ YEAR * group + (1|SALID1), 
  data = gbmt_log_merged %>% filter(Clusters == 4)
)

performance(model_4) %>% print_html()
parameters(model_4) %>% print_html()
parameters(model_4, standardize = "basic") %>% print_html()
```

### Poisson

```{r}
model_3_poisson <- glmer(
  deaths ~ YEAR * group + (1|SALID1), 
  data = gbmt_log_merged %>% filter(Clusters == 3),
  family = poisson(link = "log")
)

performance(model_3_poisson) %>% print_html()

parameters(model_3_poisson) %>% print_html()
parameters(model_3_poisson, exponentiate = TRUE) %>% print_html()


model_4_poisson <- glmer(
  deaths ~ YEAR * group + (1|SALID1), 
  data = gbmt_log_merged %>% filter(Clusters == 4),
  family = poisson(link = "log")
)

performance(model_4_poisson) %>% print_html()

parameters(model_4_poisson) %>% print_html()
parameters(model_4_poisson, exponentiate = TRUE) %>% print_html()
```

## Modelo 2 - Con offset

### Estimación

Estimación de los modelos con la información poblacional como offset

```{r}
model_3_poisson_off <- glmer(
  deaths ~ YEAR * group + (1|SALID1)  + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 3),
  family = poisson(link = "log")
)

performance(model_3_poisson_off) %>% print_html()

parameters(model_3_poisson_off) %>% print_html()
parameters(model_3_poisson_off, exponentiate = TRUE) %>% print_html()

model_4_poisson_off <- glmer(
  deaths ~ YEAR * group + (1|SALID1) + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 4),
  family = poisson(link = "log")
)

performance(model_4_poisson_off) %>% print_html()

parameters(model_4_poisson_off) %>% print_html()
parameters(model_4_poisson_off, exponentiate = TRUE) %>% print_html()
```

Ingreso de los valores predictivos para los modelos de 3 y 4 clústers:

```{r}
gbmt_log_merged2 <- gbmt_log_merged %>% 
  group_nest(Clusters) %>% 
  mutate(
    data = map2(
      data, Clusters,
      ~ case_when(
        .y == 3 ~ mutate(
          .x, 
          predicted_deaths = predict(model_3_poisson_off, type = "response"),
        ),
        .y == 4 ~ mutate(
          .x, 
          predicted_deaths = predict(model_4_poisson_off, type = "response"),
        ),
      )
    )
  ) %>% 
  unnest()

gbmt_log_merged2 <- gbmt_log_merged2 %>% 
  mutate(
    predicted_deaths_100k = predicted_deaths / population_imp * 100000
  )
```

### Gráfico

Debido a que se ha agregado a los interceptos de las ciudades como efecto aleatorio, entonces las estimaciones y predicciones van a variar de ciudad a ciudad. Para poder visualizarlo, se podría resumir los datos con su media.

```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_poisson_offset <- gbmt_log_merged2 %>% 
  group_by(Clusters, group, YEAR) %>% 
  summarise(
    across(
      c(predicted_deaths_100k, 
        deaths_per_100k),
      mean
    )
  ) %>% 
  ungroup() %>% 
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line() +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_poisson_offset
```



```{r}
#| eval: false

ggsave(
  plot_poisson_offset,
  filename = "02_output/plots/promedio_muertes_group_poisson.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_poisson_offset_g <- gbmt_log_merged2 %>% 
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line(aes(group = SALID1)) +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_grid(vars(Clusters), vars(group)) +
  # facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_poisson_offset_g
```

```{r}
#| eval: false

ggsave(
  plot_poisson_offset_g,
  filename = "02_output/plots/promedio_muertes_group_poisson_g.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


## Modelo 3 - Con offset sin efectos aleatorios

### Estimación

Las estimaciones no consideran variaciones entre las ciudades

```{r}
model_3_poisson_off2 <- glm(
  deaths ~ YEAR * group + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 3),
  family = poisson(link = "log")
)

performance(model_3_poisson_off2) %>% print_html()

parameters(model_3_poisson_off2) %>% print_html()
parameters(model_3_poisson_off2, exponentiate = TRUE) %>% print_html()

model_4_poisson_off2 <- glm(
  deaths ~ YEAR * group + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 4),
  family = poisson(link = "log")
)
performance(model_4_poisson_off2) %>% print_html()

parameters(model_4_poisson_off2) %>% print_html()
parameters(model_4_poisson_off2, exponentiate = TRUE) %>% print_html()
```

Ingreso de las predicciones en el df:

```{r}
gbmt_log_merged3 <- gbmt_log_merged %>% 
  group_nest(Clusters) %>% 
  mutate(
    data = map2(
      data, Clusters,
      ~ case_when(
        .y == 3 ~ mutate(
          .x, 
          predicted_deaths = predict(model_3_poisson_off2, type = "response"),
        ),
        .y == 4 ~ mutate(
          .x, 
          predicted_deaths = predict(model_4_poisson_off2, type = "response"),
        ),
      )
    )
  ) %>% 
  unnest(cols = c(data))

gbmt_log_merged3 <- gbmt_log_merged3 %>% 
  mutate(
    predicted_deaths_100k = predicted_deaths / population_imp * 100000
  )
```


### Gráfico

Gráfico de los datos resumidos:

```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_poisson2_offset <- gbmt_log_merged3 %>% 
  group_by(Clusters, group, YEAR) %>%
  summarise(
    across(
      c(predicted_deaths_100k,
        deaths_per_100k),
      mean
    )
  ) %>%
  ungroup() %>%
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line(linewidth = 1) +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo a lo largo del Tiempo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_poisson2_offset
```

```{r}
#| eval: false

ggsave(
  plot_poisson2_offset,
  filename = "02_output/plots/promedio_muertes_group_poisson2.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


Sin resumir:

```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_poisson2_offset_g <- gbmt_log_merged2 %>% 
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line(linewidth = 1) +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo a lo largo del Tiempo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_poisson2_offset_g
```


```{r}
#| eval: false

ggsave(
  plot_poisson2_offset_g,
  filename = "02_output/plots/plot_poisson2_offset_g.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


## Modelo 4 - Con offset Binomial negativa

### Estimación

Estimación de los modelos con la información poblacional como offset

```{r}
model_3_binomial_neg <- glmmTMB(
  deaths ~ YEAR * group + (1|SALID1) + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 3),
  family = nbinom2(link = "log")
)


performance(model_3_binomial_neg) %>% print_html()

parameters(model_3_binomial_neg) %>% print_html()
parameters(model_3_binomial_neg, exponentiate = TRUE) %>% print_html()

model_4_binomial_neg <- glmmTMB(
  deaths ~ YEAR * group + (1|SALID1) + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 4),
  family = nbinom2(link = "log")
)


performance(model_4_binomial_neg) %>% print_html()

parameters(model_4_binomial_neg) %>% print_html()
parameters(model_4_binomial_neg, exponentiate = TRUE) %>% print_html()
```


Ingreso de los valores predictivos para los modelos de 3 y 4 clústers:

```{r}
gbmt_log_merged4 <- gbmt_log_merged %>% 
  group_nest(Clusters) %>% 
  mutate(
    data = map2(
      data, Clusters,
      ~ case_when(
        .y == 3 ~ mutate(
          .x, 
          predicted_deaths = predict(model_3_binomial_neg, type = "response"),
        ),
        .y == 4 ~ mutate(
          .x, 
          predicted_deaths = predict(model_4_binomial_neg, type = "response"),
        ),
      )
    )
  ) %>% 
  unnest()

gbmt_log_merged4 <- gbmt_log_merged4 %>% 
  mutate(
    predicted_deaths_100k = predicted_deaths / population_imp * 100000
  )
```

### Gráfico

Debido a que se ha agregado a los interceptos de las ciudades como efecto aleatorio, entonces las estimaciones y predicciones van a variar de ciudad a ciudad. Para poder visualizarlo, se podría resumir los datos con su media.

```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_binomialoffset <- gbmt_log_merged4 %>% 
  group_by(Clusters, group, YEAR) %>% 
  summarise(
    across(
      c(predicted_deaths_100k, 
        deaths_per_100k),
      mean
    )
  ) %>% 
  ungroup() %>% 
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line() +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_binomialoffset
```

```{r}
#| eval: false

ggsave(
  plot_binomialoffset,
  filename = "02_output/plots/promedio_muertes_group_binomial.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_binomialoffset_g <- gbmt_log_merged4 %>% 
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line(aes(group = SALID1)) +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_grid(vars(Clusters), vars(group)) +
  # facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_binomialoffset_g
```


```{r}
#| eval: false

ggsave(
  plot_binomialoffset_g,
  filename = "02_output/plots/promedio_muertes_group_binomial_g.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```

## Modelo 5 - Con offset sin efectos aleatorios - Binomial Negativo

### Estimación

Las estimaciones no consideran variaciones entre las ciudades

```{r}
model_3_binomial_neg2 <- glm.nb(
  deaths ~ YEAR * group + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 3)
)


performance(model_3_binomial_neg2) %>% print_html()

parameters(model_3_binomial_neg2) %>% print_html()
parameters(model_3_binomial_neg2, exponentiate = TRUE) %>% print_html()

model_4_binomial_neg2 <- glm.nb(
  deaths ~ YEAR * group + offset(log(population_imp)), 
  data = gbmt_log_merged %>% filter(Clusters == 4)
)


performance(model_4_binomial_neg2) %>% print_html()

parameters(model_4_binomial_neg2) %>% print_html()
parameters(model_4_binomial_neg2, exponentiate = TRUE) %>% print_html()
```

Ingreso de las predicciones en el df:

```{r}
gbmt_log_merged5 <- gbmt_log_merged %>% 
  group_nest(Clusters) %>% 
  mutate(
    data = map2(
      data, Clusters,
      ~ case_when(
        .y == 3 ~ mutate(
          .x, 
          predicted_deaths = predict(model_3_binomial_neg2, type = "response"),
        ),
        .y == 4 ~ mutate(
          .x, 
          predicted_deaths = predict(model_4_binomial_neg2, type = "response"),
        ),
      )
    )
  ) %>% 
  unnest(cols = c(data))

gbmt_log_merged5 <- gbmt_log_merged5 %>% 
  mutate(
    predicted_deaths_100k = predicted_deaths / population_imp * 100000
  )
```


### Gráfico

Gráfico de los datos resumidos:

```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_binomial2offset <- gbmt_log_merged5 %>% 
  group_by(Clusters, group, YEAR) %>%
  summarise(
    across(
      c(predicted_deaths_100k,
        deaths_per_100k),
      mean
    )
  ) %>%
  ungroup() %>%
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line(linewidth = 1) +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo a lo largo del Tiempo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()

plot_binomial2offset
```

```{r}
#| eval: false

ggsave(
  plot_binomial2offset,
  filename = "02_output/plots/promedio_muertes_group_binomial2.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


Sin resumir:

```{r}
#| dpi: 300
#| fig-width: 7
#| fig-height: 4.5

plot_binomial2offset_g <- gbmt_log_merged5 %>% 
  ggplot(aes(x = YEAR, 
           y = predicted_deaths_100k,
           color = group)) + 
  geom_point(aes(y = deaths_per_100k), alpha = 0.5,
             position = position_jitter(h = 0.2)) +  # Datos observados
  geom_line(linewidth = 1) +
  labs(title = "Promedio de Muertes por 100,000 habitantes por Grupo a lo largo del Tiempo",
       x = "Año", y = "Muertes esperadas por 100,000 habitantes", color = "Grupo") +
  facet_wrap(vars(Clusters)) +
  theme_minimal()
```


```{r}
#| eval: false

ggsave(
  plot_binomial2offset_g,
  filename = "02_output/plots/promedio_muertes_group_binomial2_g.png",
  dpi = 300,
  bg = "white",
  width = 7,
  height = 4.5
)
```


# Mapa

```{r}
library(sf)
library(biscale)
```

```{r}
salid1_pubsalid1 <- readr::read_csv("01_data/raw/SALID1_PUBSALID1.csv")
gdb_path <- "01_data/raw/Data Request MS242_09222023/MS242_L1.gdb"
gdb_salurbal <- st_layers(gdb_path)

# cities_l1ad <- st_read(
#   gdb_path,
#   gdb_salurbal$name[[1]]
# ) %>%
#   as_tibble() %>%
#   st_as_sf() %>%
#   left_join(
#     salid1_pubsalid1
#   ) %>%
#   relocate(SALID1, .after = PUBSALID1)

cities_l1ad_noislands <- st_read(
  gdb_path,
  gdb_salurbal$name[[2]]
) %>%
  as_tibble() %>%
  st_as_sf() %>%
  left_join(
    salid1_pubsalid1
  ) %>%
  relocate(SALID1, .after = PUBSALID1)
```


```{r}
get_shp <- function(ISO2) {
  # Obtener shp_1
  shp_0 <- geodata::gadm(
    ISO2,
    path = "01_data/raw/shp/",
    level = 0
  ) %>%
    st_as_sf()
  
  # Obtener shp_1
  shp_1 <- geodata::gadm(
    ISO2,
    path = "01_data/raw/shp/",
    level = 1
  ) %>%
    st_as_sf()

  # Obtener shp_2 y aplicar las transformaciones
  shp_2 <- cities_l1ad_noislands %>%
    filter(COUNTRYAB == ISO2) %>%
    janitor::clean_names()

  # Devolver la lista con shp_1 y shp_2
  list(
    shp_0 = shp_0,
    shp_1 = shp_1,
    shp_2 = shp_2
  )
}


shp_list <- unique(gbmt_fit_final$gbmt_fit_total[[1]]$ISO2) %>%
  append(
    c("GUY", "SUR", "BOL", "PRY",
      "URY", "ECU", "BLZ", "HND",
      "TTO", "VEN")
  ) %>% 
  set_names() %>%
  map(get_shp)
```


```{r}
join_data_shp3 <- function(data, shp_list) {
  # Proceso de unión con shapefiles
  data %>%
    mutate(
      pubsalid1 = as.numeric(as.character(pubsalid1)),
      # City = str_to_lower(City),
      group = factor(group)
    ) %>%
    group_nest(ISO2) %>%
    drop_na(ISO2) %>%
    mutate(
      # country = str_to_title(country),
      shp_1 = map(ISO2, ~ shp_list[[.x]]$shp_1),
      shp_2 = map(ISO2, ~ shp_list[[.x]]$shp_2),
      shp_inner = map2(
        data,
        shp_2,
        ~ inner_join(
          .x,
          .y,
          by = join_by(pubsalid1)
        ) %>%
          st_as_sf()
      )
    )
}
```

```{r}
gbmt_interest_deaths <- gbmt_log_merged %>% 
  filter(Clusters == 4) %>% 
  group_by(
    across(c(ISO2:SALID1, group))
  ) %>% 
  summarise(
    mean_deaths_per_100k = mean(deaths_per_100k, na.rm = TRUE)
  ) %>% 
  ungroup()

gbmt_interest_deaths_shp <- map(
  list(gbmt_interest_deaths),
  ~ join_data_shp3(.x, shp_list)
)

city_data_deaths <- gbmt_interest_deaths_shp[[1]] %>% 
  select(ISO2, shp_inner) %>% 
  unnest(cols = shp_inner) %>%
  st_as_sf() %>%
  st_centroid()
```


```{r}
country_data <- map(shp_list, 1) %>% 
  bind_rows() %>% 
  mutate(
    study = c(rep(TRUE, 11), rep(FALSE, 10))
  )

countries_by_study <- country_data %>% 
  as_tibble() %>% 
  select(GID_0, study)

level1_data <- map(shp_list, 2) %>% 
  bind_rows() %>% 
  left_join(countries_by_study)
```



```{r}
#| fig-dpi: 600
#| fig-width: 7
#| fig-height: 7

city_data_deaths_biscale <- bi_class(city_data_deaths,
  x = mean_deaths_per_100k,
  y = group,
  style = "quantile", dim = 4
)

city_data_deaths %>% 
 mutate(a = ntile(mean_deaths_per_100k, 4)) %>% 
 group_by(group, a) %>% 
 summarise(min = min(mean_deaths_per_100k), max = max(mean_deaths_per_100k))

custom_pal <- c(
  "1-1" = "#e6ccf5",  # Morado muy claro
  "2-1" = "#c98bd9",  # Morado claro intensificado
  "3-1" = "#8a5599",  # Morado oscuro
  "4-1" = "#562f61",  # Morado muy oscuro
  "1-2" = "#b9f2a1",  # Verde muy claro
  "2-2" = "#6ed965",  # Verde claro intensificado
  "3-2" = "#348c3f",  # Verde oscuro
  "4-2" = "#1e5630",  # Verde muy oscuro
  "1-3" = "#a3e4fd",  # Azul celeste muy claro
  "2-3" = "#5cb8e6",  # Azul claro intensificado
  "3-3" = "#2d6899",  # Azul oscuro
  "4-3" = "#1a4467",  # Azul marino muy oscuro
  "1-4" = "#ffaba8",  # Coral muy claro
  "2-4" = "#ff5747",  # Rojo claro intensificado
  "3-4" = "#c7322c",  # Rojo oscuro
  "4-4" = "#8b1b15"   # Burdeos muy oscuro
)




ggmap <- level1_data %>%
  ggplot() +
  geom_sf(
    aes(fill = study),
    linewidth = 0.05
  ) +
  scale_fill_manual(
    values = c("#bdbdbd", "#e5e5e5"),
    guide = "none"
  ) + 
  geom_sf(
    data = country_data,
    linewidth = 0.35, 
    color = "#3f3f3f",
    fill = NA
  ) +
  geom_sf(
    data = city_data_deaths_biscale,
    mapping = aes(color = bi_class),
    #color = "white", 
    size = 2.5,
    show.legend = FALSE
  ) +
  bi_scale_color(pal = custom_pal, dim = 4) +
  bi_theme()

legend <- bi_legend(
  pal = custom_pal,
  dim = 4,
  xlab = "Mortality per 100K inhabitants",
  ylab = "Cluster (1-4)",
  size = 5
)

x_range_map2 <- city_data_deaths_biscale %>% 
  separate_wider_delim(
    bi_class,
    delim = "-",
    names = c("X", "Y")
  ) %>% 
  group_by(X) %>% 
  summarise(
    min = min(mean_deaths_per_100k),
    max = max(mean_deaths_per_100k)
  ) %>% 
  mutate(
    across(
      min:max,
      round
    ),
    range = paste0("[", min, "; \n", max, "]")
  ) 

legend <- legend + 
  scale_x_continuous(
    labels = c(NA, x_range_map2$range, NA)
  ) +
  scale_y_continuous(
    labels = c(NA, 1:4, NA)
  ) + 
  theme(
    axis.text = element_text(),
    axis.title.y = element_text(
      margin = margin(r = 4)
    ),
    axis.title.x = element_text(
      margin = margin(t = 4)
    )
  )


library(cowplot)

finalPlot <- ggdraw(ggmap) +
  # draw_plot(ggmap, 0, 0, 1.5, 1.5) +
  draw_plot(legend, 0.15, 0.25, 0.27, 0.27)

finalPlot
```

```{r}
#| eval: false

ggsave("ggmap2.png",
       finalPlot,
       height = 7,
       width = 7,
       dpi = 600)
```




